# 一、SLF4J简介 #

SLF4J（Simple logging facade for Java不是一个真正的日志实现，而是一个抽象层（ abstraction layer），它允许你在后台使用任意一个日志类库。如果是在编写供内外部都可以使用的API或者通用类库，那么你真不会希望使用你类库的客户端必须使用你选择的日志类库。
在你的代码中使用SLF4J写日志语句的主要出发点是使得你的程序独立于任意特定的日志类库，依赖于特定类可能需要不同与你已有的配置，并且导致更多维护的麻烦。
但除此之外，还要一个SLF4J API的特性使得我坚持使用SLF4J而抛弃我长期间钟爱的Lof4j的理由
大家应该还记得，在log4j中，为了提高运行效率，往往在输出信息之前，还要进行级别判断，以避免无效的字符串连接操作。但肯定这一点都不有趣并且降低了代码可读性因为增加了不必要的繁琐重复代码(boiler-plate code)：如下：

    if (logger.isDebugEnabled()) {
    	logger.debug("Processing trade with id: " + id + " symbol: " + symbol);
    }

slf4j巧妙的解决了这个问题：先传入带有占位符的字符串，同时把其他参数传入，在slf4j的内部实现中，如果级别合适再去用传入的参数去替换字符串中的占位符，否则不用执行。
这种格式非常简洁：

    logger.debug("Processing trade with id: {} and symbol : {} ", id, symbol);

# 二、maven依赖  #
使用SLF4J+log4j2需要的jar包：slf4j-api；log4j-api；log4j-core；log4j-slf4j-impl(集成包)。pom文件如下：

	<dependency>
		<groupId>org.apache.logging.log4j</groupId>
		<artifactId>log4j-api</artifactId>
		<version>2.7</version>
	</dependency>
	<dependency>
		<groupId>org.apache.logging.log4j</groupId>
		<artifactId>log4j-core</artifactId>
		<version>2.7</version>
	</dependency>
	<dependency>
		<groupId>org.apache.logging.log4j</groupId>
		<artifactId>log4j-slf4j-impl</artifactId>
		<version>2.7</version>
	</dependency>
	<dependency>
		<groupId>org.slf4j</groupId>
		<artifactId>slf4j-api</artifactId>
		<version>1.7.21</version>
	</dependency>

# 三、log4j自动配置 #

Log4j has the ability to automatically configure itself during initialization. When Log4j starts it will locate all the ConfigurationFactory plugins and arrange them in weighted order from highest to lowest. As delivered, Log4j contains four ConfigurationFactory implementations: one for `JSON`, one for 
`YAML`, one for `properties`, and one for `XML`.

1. Log4j will inspect the `"log4j.configurationFile"` system property and, if set, will attempt to load the configuration using the `ConfigurationFactory` that matches the file extension.
1. If no system property is set the properties ConfigurationFactory will look for `log4j2-test.properties` in the classpath.
1. If no such file is found the YAML ConfigurationFactory will look for `log4j2-test.yaml` or `log4j2-test.yml` in the classpath.
1. If no such file is found the JSON ConfigurationFactory will look for `log4j2-test.json` or `log4j2-test.jsn` in the classpath.
1. If no such file is found the XML ConfigurationFactory will look for `log4j2-test.xml` in the classpath.
1. If a test file cannot be located the properties ConfigurationFactory will look for `log4j2.properties` on the classpath.
1. If a properties file cannot be located the YAML ConfigurationFactory will look for `log4j2.yaml` or `log4j2.yml` on the classpath.
1. If a YAML file cannot be located the JSON ConfigurationFactory will look for `log4j2.json` or `log4j2.jsn` on the classpath.
1. If a JSON file cannot be located the XML ConfigurationFactory will try to locate `log4j2.xml` on the classpath.
1. If no configuration file could be located the `DefaultConfiguration` will be used. This will cause logging output to go to the console.

# 四、指定log4j配置文件 #

如果想将配置文件重命名并放到别处，就需要设置系统属性log4j.configurationFile,设置的方式是在VM arguments中写入该属性的key和value：

    java -Dlog4j.configurationFile="C:\Users\pengqb\git\pearls\pearls-iot\statistics\target\classes\log4j2.xml" -jar statistics.jar

或者，打包时直接把log4j2.xml 打包进jar，同时删除log4j里默认配置log4j2-test.properties。pom.xml配置如下：

	<build>
		<sourceDirectory>src/main/java</sourceDirectory>
		<resources>
			<resource>
				<directory>src/main/resources</directory>
				<targetPath>${project.build.directory}/classes</targetPath>
				<excludes>
					<exclude>**/*.java</exclude>
				</excludes>
			</resource>
		</resources>
		...
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-shade-plugin</artifactId>
				<version>${shade.version}</version>
				<configuration>
					<createDependencyReducedPom>true</createDependencyReducedPom>
					<filters>
						<filter>
							<artifact>*:*</artifact>
							<excludes>								
								<exclude>META-INF/*.RSA</exclude>
								<exclude>log4j2-test.properties</exclude>
							</excludes>			
						</filter>
					</filters>
				</configuration>
				...
			</plugin>
		</plugins>
	</build>

# 五、日志配置 #

    <?xml version="1.0" encoding="UTF-8"?>
    <!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出。 -->
    <!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数。 -->
    <configuration status="error" monitorInterval="30">
	<Properties>
		<!-- ${sys:catalina.home}/logs -->
		<Property name="logpath">/var/logs</Property>
	</Properties>
	<appenders>
		<Console name="Console" target="SYSTEM_OUT">
			<!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch） -->
			<ThresholdFilter level="debug" onMatch="ACCEPT"
				onMismatch="DENY" />
			<PatternLayout
				pattern="%d{HH:mm:ss.SSS} %-5level %class{36} %L %M - %msg%xEx%n" />
		</Console>
		<!--append=“false”指定不追加到文件末尾,即每次运行程序会自动清空，这个也挺有用的，适合临时测试用 -->
		<File name="log" fileName="${logpath}/api.log" append="false">
			<PatternLayout
				pattern="%d{HH:mm:ss.SSS} %-5level %class{36} %L %M - %msg%xEx%n" />
		</File>
		<RollingFile name="fileapi" fileName="${logpath}/api.log"
			filePattern="${logpath}/api-%d{yyyy-MM-dd-HH}.log">
			<PatternLayout
				pattern="%d ${hostName} %p %c{1.} [%t] %m %ex%n">
			</PatternLayout>
			<Policies>
				<TimeBasedTriggeringPolicy modulate="true"
					interval="1" />
			</Policies>
		</RollingFile>
	</appenders>
	<loggers>
		<!--我们只让这个logger输出dubug信息，其他的都是info级别 -->
		<!-- additivity默认为true，由于这个logger也是满足root的，所以会被打印两遍。additivity=“false”可以避免父级遗传,只打印一遍 -->
		<logger name="com.vela.iot.statistics" level="debug"
			additivity="false">
			<appender-ref ref="fileapi" />
			<appender-ref ref="Console" />
		</logger>
		<root level="info" additivity="false">
			<appender-ref ref="fileapi" />
			<appender-ref ref="Console" />
		</root>
	</loggers>
    </configuration>

#六、Servlet 2.5 Web Applications和log4j2结合的问题 #

    http://logging.apache.org/log4j/2.x/manual/webapp.html

    <listener>
    	<listener-class>org.apache.logging.log4j.web.Log4jServletContextListener</listener-class>
    </listener>
    <filter>
    	<filter-name>log4jServletFilter</filter-name>
    	<filter-class>org.apache.logging.log4j.web.Log4jServletFilter</filter-class>
    </filter>
    <filter-mapping>
    	<filter-name>log4jServletFilter</filter-name>
    	<url-pattern>/*</url-pattern>
    	<dispatcher>REQUEST</dispatcher>
    	<dispatcher>FORWARD</dispatcher>
    	<dispatcher>INCLUDE</dispatcher>
    	<dispatcher>ERROR</dispatcher>
    </filter-mapping>

# 七、异步日志 #

## 1、配置 ##    
log4j2异步日志依赖disruptor，Disruptor它是一个开源的并发框架，并获得2011 Duke’s 程序框架创新奖，能够在无锁的情况下实现网络的Queue并发操作。需要在pom.xml里增加maven依赖：

	<dependency>
		<groupId>com.lmax</groupId>
		<artifactId>disruptor</artifactId>
		<version>3.3.6</version>
	</dependency>

## 2、设置系统属性，启动时带上如下虚拟机参数： ##

    -DLog4jContextSelector =org.apache.logging.log4j.core.async.AsyncLoggerContextSelector

## 3、具体xml配置 ##

	<?xml version="1.0" encoding="UTF-8"?>
	<!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出。 -->
	<!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数。 -->
	<!-- Don't forget to set system property -DLog4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector 
		to make all loggers asynchronous. -->
	<configuration status="error" monitorInterval="30">
		<Properties>
			<Property name="logpath">/var/log</Property>
		</Properties>
		<appenders>
			<!-- Async Loggers will auto-flush in batches, so switch off immediateFlush. -->
			<RollingFile name="fileapi" fileName="${logpath}/active.log"
				filePattern="${logpath}/active-%d{yyyy-MM-dd-HH}.log" immediateFlush="false" append="false">			
				<PatternLayout				
					pattern="%d ${hostName} %p %c{1.} [%t] %m %ex%n">
				</PatternLayout>
				<Policies>
					<TimeBasedTriggeringPolicy modulate="true"
						interval="1" />
				</Policies>
			</RollingFile>
		</appenders>
		<loggers>
			<root level="INFO" includeLocation="false" additivity="false">
				<appender-ref ref="fileapi" /> 
			</root>
		</loggers>
	</configuration>

## 4、异步日志对性能的影响 ##
异步日志对性能的影响还是很大的，具体见我的netty文章，里面有性能影响的测试结果。	

# 八、kafka #
    http://logging.apache.org/log4j/2.x/manual/appenders.html#KafkaAppender

# 九、syslog #
    http://logging.apache.org/log4j/2.x/manual/appenders.html#SyslogAppender

参考

	https://logging.apache.org/log4j/2.x/manual/async.html#Performance